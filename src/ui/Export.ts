import {updateImage} from "./UpdateImage.js";
import {config} from "../config/Config.js";
import {generateSTLAndDownload, getHeights} from "../tools/HeightmapExport.js";
import {Filament} from "../Filament.js";

const exportButtonSTL = document.getElementById('export-stl') as HTMLButtonElement;

const detailSizeInput = document.getElementById('detail-size') as HTMLInputElement;

const imageResolutionX = document.getElementById('image-resolution-x') as HTMLInputElement;
const imageResolutionY = document.getElementById('image-resolution-y') as HTMLInputElement;

const physicalXInput = document.getElementById('physical-x') as HTMLInputElement;
const physicalYInput = document.getElementById('physical-y') as HTMLInputElement;

const instructions = document.getElementById('instructions') as HTMLInputElement;

const baseLayerHeight = document.getElementById('base-layer-height-input') as HTMLInputElement;
const globalLayerHeightInput = document.getElementById('layer-height-input') as HTMLInputElement; // Get global input

function getUniqueFilaments(filaments: Filament[]): Filament[] {
    const uniqueFilaments: Filament[] = [];
    const seenFilaments = new Set<string>();

    for (const filament of filaments) {
        const key = `${filament.colour[0]}-${filament.colour[1]}-${filament.colour[2]}-${filament.name}-${filament.opacity}`;
        if (!seenFilaments.has(key)) {
            uniqueFilaments.push(filament);
            seenFilaments.add(key);
        }
    }

    return uniqueFilaments;
}

export function setupExport() {
    exportButtonSTL.addEventListener('click', (e) => {
        updateImage();

        if (config.paint.image.width == 0) {
            console.log('No image')
            return;
        }

        let heights = getHeights(config.paint.computedResult, config.paint.image.width, config.paint.image.height);
        let pixelX = parseFloat(imageResolutionX.value);
        if (pixelX < 2) {
            return;
        }

        let pixelScaleFactor = pixelX / (pixelX - 1);
        let sizeScaleFactor = parseFloat(detailSizeInput.value);

        let scaleFactor = pixelScaleFactor * sizeScaleFactor;

        generateSTLAndDownload(heights, 'filamentPainting.stl', scaleFactor);

        let filamentsUsed = getUniqueFilaments(config.paint.filaments);

        let filamentsString = ''

        for (let filament of filamentsUsed) {
            filamentsString += `${filament.name} - Opacity ${filament.opacity} mm\n`;
        }

        let swapString = ''

        for (let i = 0; i < config.paint.filaments.length; i++) {
            let filament = config.paint.filaments[i];
            if (i == 0) {
                swapString += `- Begin with ${filament.name} as the first layer\n`;
            } else {
                swapString += `- Swap to ${filament.name} at a layer height of ${Math.round((config.paint.filaments[i - 1].endHeight + parseFloat(globalLayerHeightInput.value)) * 100) / 100} mm\n`;
            }
        }

        let instructionString = `Generated by painter.vec4.ca.

Filament Library:
${filamentsString}
        
Print Instructions:
Set base layer height to ${baseLayerHeight.value} mm and layer height to ${globalLayerHeightInput.value} mm.
${swapString}`;

        instructions.innerHTML = instructionString;

        downloadTextFile("Filament Painter Instructions.txt", instructionString);
    })
}

function downloadTextFile(filename: string, content: string): void {
    const blob = new Blob([content], { type: "text/plain" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();

    // Cleanup
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
